# Server Side APIs: Part 2 Tutorial

In this tutorial, you'll continue working on an application that uses meetup locations as the data model. You'll add the ability to update and delete a location as well as perform data validation to inform the client of any problems.

## Step One: Open project in IntelliJ and explore starting code

Open the server-side APIs part 2 tutorial in IntelliJ. After you've opened the project, review the starting code.

### DAO

In the previous tutorial, the `LocationController` constructor instantiated the list of locations. For this tutorial, all of the data initialization and CRUD operations are in the `MemoryLocationDao` class. This mimics using a real database, but the data is only stored in the memory of your computer.

The `LocationController` constructor receives a new DAO instance at runtime by the Spring framework using Dependency Injection:

```java
public LocationController(LocationDao locationDao) {
    this.locationDao = locationDao;
}
```

If you open the `LocationDao.java` file, you'll notice it's an interface. The `MemoryLocationDao` class implements this interface. It's annotated with `@Component` so that Spring framework can inject it into the `LocationController`:

```java
@Component
public class MemoryLocationDao implements LocationDao {
    ...
}
```

The existing controller methods now use the DAO to retrieve location data.

### Controller update

In the previous version of this application, you defined each of the `@RequestMapping()` paths at the method level. If you have a base path like `/locations`, and you find yourself reusing it several times, you can move it to the class level:

```java
@RestController
@RequestMapping("/locations")
public class LocationController {

}
```

If the path for listing locations is `/locations`, you enter an empty string to use the inherited path from the class level `@RequestMapping("/locations")`:

```java
@RequestMapping(path = "", method = RequestMethod.GET)
public List<Location> list() {
    return locationDao.getLocations();
}
```

The `get()` method was also updated from the previous tutorial. Now the method throws a `ResponseStatusException` if the DAO returns `null`, which means there's no location for the ID provided. It's best practice to return a `404(NotFound)` status code when a resource isn't found:

```java
@RequestMapping(path = "/{id}", method = RequestMethod.GET)
public Location get(@PathVariable int id) {
    Location location = locationDao.getLocationById(id);
    if (location == null) {
        throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Location not found");
    } else {
        return location;
    }
}
```

## Step Two: Run your project

Now that you've set up your project in IntelliJ and reviewed the starting code, run it to verify that it works as expected. It's best to make sure the application runs before adding anything new to it.

## Step Three: Add Location data validation

In the previous tutorial, there was some basic validation in the `add()` method of the controller. If the location wasn't null, you'd add it to the list of locations:

```java
@RequestMapping(path = "/locations", method = RequestMethod.POST)
public Location add(@RequestBody Location location) {
    if (location != null) {
        locations.add(location);
        return location;
    }
    return null;
}
```

What happens if the location isn't null but is missing information? For locations, you want to require all of these fields so they may not be blank:

- name
- address
- city
- state
- zip

If you open `Location.java`, you'll see the list of fields for this class. Before looking at the answer, add the `@NotBlank()` annotation for each required field:

```java
public class Location {

    private int id;
    private String name;
    private String address;
    private String city;
    private String state;
    private String zip;

}
```

> The `id` isn't required because it's generated by the `MemoryLocationDao` class.

Next, add a custom message by setting the message parameter of the `@NotBlank` annotation. Remember that adding custom messages helps the client understand what field failed data validation:

```java
public class Location {

    private int id;
    @NotBlank(message = "The field name is required.")
    private String name;
    @NotBlank(message = "The field address is required.")
    private String address;
    @NotBlank(message = "The field city is required.")
    private String city;
    @NotBlank(message = "The field state is required.")
    private String state;
    @NotBlank(message = "The field zip is required.")
    private String zip;

}
```

## Step Four: Create a new location

Now that you have validation in your `Location` class, you'll need to make sure the controller receives a *valid* argument. To check them in your controller, you need to add the `@Valid` annotation to the model:

```java
@RequestMapping(path = "", method = RequestMethod.POST)
public Location add(@Valid @RequestBody Location location) {
    return locationDao.createLocation(location);
}
```

This is also a good time to fix another issue from the previous tutorial. If you open Postman and create a new `Location`, what status code do you receive?

Right now, you get back a `200(OK)` status code, but it's best practice to return a `201(Created)` status code so the client knows about the creation of the new resource. You can use the `@ResponseStatus` annotation on the controller method and specify what status code to return:

```java
@ResponseStatus(HttpStatus.CREATED)
@RequestMapping(path = "", method = RequestMethod.POST)
public Location add(@Valid @RequestBody Location location) {
    return locationDao.createLocation(location);
}
```

Feel free to test this method in Postman. If you send an object with a blank name, do you get the proper error message back? What status code do you get for a successful request?

## Step Five: Update an existing location

To add the ability to update an existing location, you need to create a new controller method that responds to the `PUT` request method. A client specifies the URL to a specific location, like `locations/1`, and sends the JSON data that includes the updated location.

In `LocationController`, create a new method called `update()`:

```java
@RequestMapping(path = "/{id}", method = RequestMethod.PUT)
public Location update(@Valid @RequestBody Location location, @PathVariable int id) {

}
```

Like the `add()` method, you use the `@Valid` annotation on the `Location` parameter to ensure the data sent is valid.

Next, write the body of the method. For this method, you'll call the DAO `updateLocation()` method. `updateLocation()` takes a `Location` as input. But the ID for the location to update is on the URL. It may not have been provided in the payload, or it may have been different. Either way, the ID on the URL takes precedence. Set the ID property of the `Location` object to the one from the URL.

Now the method can pass the Location to the `updateLocation()` method. If `updateLocation()` can't find the Location to update it throws a `DaoException`. The code must catch the exception and throw a `ResponseStatusException` rather than letting the `DaoException` go to the client:

```java
@RequestMapping(path = "/{id}", method = RequestMethod.PUT)
public Location update(@Valid @RequestBody Location location, @PathVariable int id) {
    // The id on the path takes precedence over the id in the request body, if any
    location.setId(id);
    try {
        Location updatedLocation = locationDao.updateLocation(location);
        return updatedLocation;
    } catch (DaoException e) {
        throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Location not found");
    }
}
```

You can test this by running a `PUT` request in Postman. If you wanted to update the Cleveland location, the path would be `http://localhost:8080/locations/1`. Make sure to change the request method to `PUT`. You can send the following object to change the name:

```json
{
    "id": 1,
    "name": "THIS IS A NEW TITLE",
    "address": "7100 Euclid Ave",
    "city": "Cleveland",
    "state": "OH",
    "zip": "44103"
}
```

If you try updating a location that doesn't exist, like `/locations/99`, what happens?

> Don't worry: the changes are only stored in memory, so you won't change this permanently. If you restart your application, you'll see the data has been reset.

## Step Six: Delete a location

Add a new `delete()` method to your controller. Like `PUT`, `DELETE` targets the URL for a specific location. Unlike the `update()` method, you won't return anything, so you'll want to make sure you return the status code `204(No Content)`:

```java
@ResponseStatus(HttpStatus.NO_CONTENT)
@RequestMapping(path = "/{id}", method = RequestMethod.DELETE)
public void delete(@PathVariable int id) {
    locationDao.deleteLocationById(id);
}
```

To test in Postman, run a `DELETE` on any of the existing locations. After running it and getting a successful `204(No Content)` status back, run the `GET` to list all of the locationsâ€”you'll see that your location that you just deleted isn't returned in the list. Like the `update()` method, try sending a `DELETE` request to a location that doesn't exist and see what happens.

## Summary

In this tutorial, you learned:

- How to add validation to your data model.
- How to validate incoming requests with the `@Valid` annotation.
- How to return a specific status code using the `@ResponseStatus` annotation.
- How to create a method that updates a resource in your controller.
- How to create a method that deletes a resource in your controller.
